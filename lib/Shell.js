// Generated by CoffeeScript 2.0.3
var EventEmitter, Interface, Request, Response, Shell, events, readline, styles, util, utils;

util = require('util');

readline = require('readline');

events = require('events');

EventEmitter = events.EventEmitter;

utils = require('./utils');

styles = require('./Styles');

Request = require('./Request');

Response = require('./Response');

// Fix readline interface
Interface = require('readline').Interface;

Interface.prototype.setPrompt = (function(parent) {
  return function(prompt, length) {
    var args;
    args = Array.prototype.slice.call(arguments);
    if (!args[1]) {
      args[1] = styles.unstyle(args[0]).length;
    }
    return parent.apply(this, args);
  };
})(Interface.prototype.setPrompt);

module.exports = function(settings) {
  return new Shell(settings);
};

Shell = (function() {
  class Shell extends EventEmitter {
    constructor(settings = {}) {
      var base, base1, base2, ref, ref1, ref2;
      super(settings);
      // EventEmitter.call @
      this.tmp = {};
      this.settings = settings;
      if ((base = this.settings).prompt == null) {
        base.prompt = '>> ';
      }
      if ((base1 = this.settings).stdin == null) {
        base1.stdin = process.stdin;
      }
      if ((base2 = this.settings).stdout == null) {
        base2.stdout = process.stdout;
      }
      this.set('env', (ref = (ref1 = this.settings.env) != null ? ref1 : process.env.NODE_ENV) != null ? ref : 'development');
      this.set('command', typeof settings.command !== 'undefined' ? settings.command : process.argv.slice(2).join(' '));
      this.stack = [];
      this.styles = styles({
        stdout: this.settings.stdout
      });
      process.on('beforeExit', () => {
        return this.emit('exit');
      });
      process.on('uncaughtException', (e) => {
        this.emit('exit', [e]);
        this.styles.red('Internal error, closing...').ln();
        console.error(e.message);
        console.error(e.stack);
        return process.exit();
      });
      this.isShell = (ref2 = this.settings.isShell) != null ? ref2 : process.argv.length === 2;
      if (this.isShell) {
        this.interface();
      }
      // Project root directory
      if (settings.workspace == null) {
        settings.workspace = utils.workspace();
      }
      if (settings.chdir === true) {
        // Current working directory
        process.chdir(settings.workspace);
      }
      if (typeof settings.chdir === 'string') {
        process.chdir(settings.chdir);
      }
      // Start
      process.nextTick(() => {
        var command, noPrompt;
        if (this.isShell) {
          command = this.set('command');
          noPrompt = this.set('noPrompt');
          if (command) {
            return this.run(command);
          } else if (!noPrompt) {
            return this.prompt();
          }
        } else {
          command = this.set('command');
          if (command) {
            return this.run(command);
          }
        }
      });
      return this;
    }

    
    // Return the readline interface and create it if not yet initialized
    interface() {
      if (this._interface != null) {
        return this._interface;
      }
      return this._interface = readline.createInterface(this.settings.stdin, this.settings.stdout);
    }

    
    // Configure callback for the given `env`
    configure(env, fn) {
      if (typeof env === 'function') {
        fn = env;
        env = 'all';
      }
      if (env === 'all' || env === this.settings.env) {
        fn.call(this);
      }
      return this;
    }

    
    // Configure callback for the given `env`
    use(handle) {
      // Add the route, handle pair to the stack
      if (handle) {
        this.stack.push({
          route: null,
          handle: handle
        });
      }
      return this;
    }

    
    // Run a command
    run(command) {
      var index, next, req, res, self;
      command = command.trim();
      this.emit('command', [command]);
      this.emit(command, []);
      self = this;
      req = new Request(this, command);
      res = new Response({
        shell: this,
        stdout: this.settings.stdout
      });
      index = 0;
      next = function(err) {
        var arity, layer, text;
        layer = self.stack[index++];
        if (!layer) {
          if (err) {
            return self.emit('error', err);
          }
          if (command !== '') {
            text = `Command failed to execute ${command}`;
            if (err) {
              text += `: ${err.message || err.name}`;
            }
            res.red(text);
          }
          return res.prompt();
        }
        arity = layer.handle.length;
        if (err) {
          if (arity === 4) {
            self.emit('error', err);
            return layer.handle(err, req, res, next);
          } else {
            return next(err);
          }
        } else if (arity < 4) {
          return layer.handle(req, res, next);
        } else {
          return next();
        }
      };
      return next();
    }

    set(setting, val) {
      if (val == null) {
        if (this.settings.hasOwnProperty(setting)) {
          return this.settings[setting];
        } else if (this.parent) {
          // for the future, parent being undefined for now
          return this.parent.set(setting);
        }
      } else {
        this.settings[setting] = val;
        return this;
      }
    }

    
    // Display prompt
    prompt() {
      var text;
      if (this.isShell) {
        text = this.styles.raw(this.settings.prompt, {
          color: 'green'
        });
        return this.interface().question(text, this.run.bind(this));
      } else {
        this.styles.ln();
        if (process.versions) {
          return this.quit();
        } else {
          
          // Node v0.6.1 throw error 'process.stdout cannot be closed'
          this.settings.stdout.destroySoon();
          return this.settings.stdout.on('close', function() {
            return process.exit();
          });
        }
      }
    }

    
    // Command quit
    quit(params) {
      this.emit('quit');
      this.interface().close();
      return this.settings.stdin.destroy();
    }

  };

  
  // Store commands
  Shell.prototype.cmds = {};

  return Shell;

})();

//@set 'stdin', null
module.exports.Shell = Shell;
