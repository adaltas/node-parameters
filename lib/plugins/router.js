// Generated by CoffeeScript 2.0.3
var match, normalize, querystring, utils,
  indexOf = [].indexOf;

utils = require('../utils');

querystring = {
  unescape: function(str) {
    return decodeURIComponent(str);
  },
  parse: function(qs, sep, eq) {
    var k, kvp, l, len, obj, ref, v, vkps, x;
    sep = sep || '&';
    eq = eq || '=';
    obj = {};
    if (typeof qs !== 'string') {
      return obj;
    }
    vkps = qs.split(sep);
    for (l = 0, len = vkps.length; l < len; l++) {
      kvp = vkps[l];
      x = kvp.split(eq);
      k = querystring.unescape(x[0], true);
      v = querystring.unescape(x.slice(1).join(eq), true);
      if (ref = !k, indexOf.call(obj, ref) >= 0) {
        obj[k] = v;
      } else if (!Array.isArray(obj[k])) {
        obj[k] = [obj[k], v];
      } else {
        obj[k].push(v);
      }
    }
    return obj;
  }
};

// produce regular expression from string
normalize = function(command, keys, sensitive) {
  // regexp factors:
  //  0. match a literal ':'
  //  1. 'key': match 1 or more word characters followed by :
  //  2. 'format': match anything inside (), should be a regexp factor ie ([0-9]+)
  //  3. 'optional': match an optional literal '?'
  command = command.concat('/?').replace(/\/\(/g, '(?:/').replace(/:(\w+)(\(.*\))?(\?)?/g, function(_, key, format, optional) {
    keys.push(key);
    format = format || '([^ ]+)'; // provide default format
    optional = optional || '';
    return format + optional;
  }).replace(/([\/.])/g, '\\$1').replace(/\*/g, '(.+)');
  return new RegExp('^' + command + '$', (sensitive != null ? 'i' : void 0));
};

match = function(req, routes, i) {
  var captures, index, j, key, keys, regexp, route, val;
  //from ?= 0
  //to = routes.length - 1
  //for (len = routes.length; i < len; ++i) {
  //for i in [from .. to]
  if (i == null) {
    i = 0;
  }
  while (i < routes.length) {
    route = routes[i];
    //fn = route.callback
    regexp = route.regexp;
    keys = route.keys;
    captures = regexp.exec(req.command);
    if (captures) {
      route.params = {};
      index = 0;
      //for (j = 1, len = captures.length; j < len; ++j) {
      //for j in [1 .. captures.length]
      j = 1;
      while (j < captures.length) {
        key = keys[j - 1];
        val = typeof captures[j] === 'string' ? querystring.unescape(captures[j]) : captures[j];
        if (key) {
          route.params[key] = val;
        } else {
          route.params['' + index] = val;
          index++;
        }
        j++;
      }
      req._route_index = i;
      return route;
    }
    i++;
  }
  return null;
};

module.exports = function(settings) {
  var params, routes, shell;
  if (!settings.shell) {
    // Validation
    throw new Error('No shell provided');
  }
  shell = settings.shell;
  if (settings.sensitive == null) {
    settings.sensitive = true;
  }
  // Expose routes
  routes = shell.routes = [];
  params = {};
  shell.param = function(name, fn) {
    if (Array.isArray(name)) {
      name.forEach(function(name) {
        return this.param(name, fn);
      }, this);
    } else {
      if (':' === name[0]) {
        name = name.substr(1);
      }
      params[name] = fn;
    }
    return this;
  };
  shell.cmd = function(command, description, middleware1, middleware2, fn) {
    var args, keys, route;
    args = Array.prototype.slice.call(arguments);
    route = {};
    route.command = args.shift();
    if (typeof args[0] === 'string') {
      route.description = args.shift();
    }
    route.middlewares = utils.flatten(args);
    keys = [];
    route.regexp = route.command instanceof RegExp ? route.command : normalize(route.command, keys, settings.sensitive);
    route.keys = keys;
    routes.push(route);
    return this;
  };
  // Register 'quit' command
  shell.cmd('quit', 'Exit this shell', shell.quit.bind(shell));
  // middleware
  return function(req, res, next) {
    var i, pass, route, self;
    route = null;
    self = this;
    i = 0;
    pass = function(i) {
      var keys, param;
      route = match(req, routes, i);
      if (!route) {
        return next();
      }
      i = 0;
      keys = route.keys;
      req.params = route.params;
      // Param preconditions
      // From expresso guide: There are times when we may want to "skip" passed 
      // remaining route middleware, but continue matching subsequent routes. To 
      // do this we invoke `next()` with the string "route" `next('route')`. If no 
      // remaining routes match the request url then Express will respond with 404 Not Found.
      param = function(err) {
        var fn, key, nextMiddleware, val;
        try {
          key = keys[i++];
          val = req.params[key];
          fn = params[key];
          if ('route' === err) {
            return pass(req._route_index + 1);
          // Error
          } else if (err) {
            return next(err);
          // Param has callback
          } else if (fn) {
            // Return style
            if (1 === fn.length) {
              req.params[key] = fn(val);
              return param();
            } else {
              // Middleware style
              return fn(req, res, param, val);
            }
          // Finished processing params
          } else if (!key) {
            // route middleware
            i = 0;
            nextMiddleware = function(err) {
              fn = route.middlewares[i++];
              if ('route' === err) {
                return pass(req._route_index + 1);
              } else if (err) {
                return next(err);
              } else if (fn) {
                return fn(req, res, nextMiddleware);
              } else {
                return pass(req._route_index + 1);
              }
            };
            //route.callback.call self, req, res, (err) ->
            //if err
            //next err
            //else
            //pass req._route_index + 1
            return nextMiddleware();
          } else {
            // More params
            return param();
          }
        } catch (error) {
          err = error;
          return next(err);
        }
      };
      return param();
    };
    return pass();
  };
};
